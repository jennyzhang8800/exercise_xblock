{"knowledge": "置换算法。", "question": "\"试描述FIFO页面替换算法的基本原理，并swap_fifo.c中未完成FIFA页面替换算法实验函数map_swappable()和swap_out_vic\r\ntim() 。 =============Defs.h (libs)============= /   to_struct - get the\r\nstruct from a ptr  @ptr: a struct pointer of member  @type: the type of the\r\nstruct this is embedded in  @member: the name of the member within the struct\r\n / #define to_struct(ptr, type, member) \\ ((type )((char )(ptr) -\r\noffsetof(type, member))) =============Memlayout.h (kern\\mm)============= //\r\nconvert list entry to page #define le2page(le, member) \\ to_struct((le),\r\nstruct Page, member) =============List.h (libs)============= #ifndef\r\n__LIBS_LIST_H__ #define __LIBS_LIST_H__ #ifndef __ASSEMBLER__ #include  /  \r\nSimple doubly linked list implementation.   Some of the internal functions\r\n(\"__xxx\") are useful when manipulating  whole lists rather than single\r\nentries, as sometimes we already know  the next/prev entries and we can\r\ngenerate better code by using them  directly rather than using the generic\r\nsingle-entry routines.  / struct list_entry { struct list_entry prev,\r\nnext; }; typedef struct list_entry list_entry_t; static inline void\r\nlist_init(list_entry_t elm) __attribute__((always_inline)); static inline\r\nvoid list_add(list_entry_t listelm, list_entry_t elm)\r\n__attribute__((always_inline)); static inline void\r\nlist_add_before(list_entry_t listelm, list_entry_t elm)\r\n__attribute__((always_inline)); static inline void list_add_after(list_entry_t\r\nlistelm, list_entry_t elm) __attribute__((always_inline)); static inline\r\nvoid list_del(list_entry_t listelm) __attribute__((always_inline)); static\r\ninline void list_del_init(list_entry_t listelm)\r\n__attribute__((always_inline)); static inline bool list_empty(list_entry_t\r\nlist) __attribute__((always_inline)); static inline list_entry_t\r\nlist_next(list_entry_t listelm) __attribute__((always_inline)); static\r\ninline list_entry_t list_prev(list_entry_t listelm)\r\n__attribute__((always_inline)); static inline void __list_add(list_entry_t\r\nelm, list_entry_t prev, list_entry_t next) __attribute__((always_inline));\r\nstatic inline void __list_del(list_entry_t prev, list_entry_t next)\r\n__attribute__((always_inline)); /   list_init - initialize a new entry \r\n@elm: new entry to be initialized  / static inline void\r\nlist_init(list_entry_t elm) { elm->prev = elm->next = elm; } /   list_add\r\nadded   Insert the new element @elm after the element @listelm which  is\r\nalready in the list.  / static inline void list_add(list_entry_t listelm,\r\nlist_entry_t elm) { list_add_after(listelm, elm); } /   list_add_before -\r\nadd a new entry  @listelm: list head to add before  @elm: new entry to be\r\nadded   Insert the new element @elm before the element @listelm which  is\r\nalready in the list.  / static inline void list_add_before(list_entry_t\r\nlistelm, list_entry_t elm) { __list_add(elm, listelm->prev, listelm); } / \r\n list_add_after - add a new entry  @listelm: list head to add after  @elm:\r\nnew entry to be added   Insert the new element @elm after the element\r\n@listelm which  is already in the list.  / static inline void\r\nlist_add_after(list_entry_t listelm, list_entry_t elm) { __list_add(elm,\r\nlistelm, listelm->next); } /   list_del - deletes entry from list \r\n@listelm: the element to delete from the list   Note: list_empty() on\r\n@listelm does not return true after this, the entry is  in an undefined\r\nstate.  / static inline void list_del(list_entry_t listelm) {\r\n__list_del(listelm->prev, listelm->next); } /   list_del_init - deletes\r\nentry from list and reinitialize it.  @listelm: the element to delete from\r\nthe list.   Note: list_empty() on @listelm returns true after this.  /\r\nstatic inline void list_del_init(list_entry_t listelm) { list_del(listelm);\r\nlist_init(listelm); } /   list_empty - tests whether a list is empty \r\n@list: the list to test.  / static inline bool list_empty(list_entry_t\r\nlist) { return list->next == list; } /   list_next - get the next entry \r\n@listelm: the list head / static inline list_entry_t \r\nlist_next(list_entry_t listelm) { return listelm->next; } /   list_prev -\r\nget the previous entry  @listelm: the list head / static inline\r\nlist_entry_t  list_prev(list_entry_t listelm) { return listelm->prev; } / \r\n Insert a new entry between two known consecutive entries.   This is only\r\nfor internal list manipulation where we know  the prev/next entries already!\r\n / static inline void __list_add(list_entry_t elm, list_entry_t prev,\r\nlist_entry_t next) { prev->next = next->prev = elm; elm->next = next;\r\nelm->prev = prev; } /   Delete a list entry by making the prev/next entries\r\npoint to each other.   This is only for internal list manipulation where we\r\nknow  the prev/next entries already!  / static inline void\r\n__list_del(list_entry_t prev, list_entry_t next) { prev->next = next;\r\nnext->prev = prev; } #endif / !__ASSEMBLER__ / #endif / !__LIBS_LIST_H__ /\r\n============= Swap_fifo.c (kern\\mm)============= #include  #include  #include\r\n\\#include  #include  #include  #include  / [wikipedia]The simplest Page\r\nReplacement Algorithm(PRA) is a FIFO algorithm.  (1) Prepare: In order to\r\nimplement FIFO PRA, we should manage all swappable pages, so we can  link\r\nthese pages into pra_list_head according the time order. At first you should \r\nbe familiar to the struct list in list.h. struct list is a simple doubly\r\nlinked list  implementation. You should know howto USE: list_init,\r\nlist_add(list_add_after),  list_add_before, list_del, list_next, list_prev.\r\nAnother tricky method is to transform  a general list struct to a special\r\nstruct (such as struct page). You can find some MACRO:  le2page (in\r\nmemlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc. /\r\nlist_entry_t pra_list_head; /  (2) _fifo_init_mm: init pra_list_head and let\r\nmm->sm_priv point to the addr of pra_list_head.  Now, From the memory control\r\nstruct mm_struct, we can access FIFO PRA / static int _fifo_init_mm(struct\r\nmm_struct mm) { list_init(&amp;pra;_list_head); mm->sm_priv =\r\n&amp;pra;_list_head; //cprintf(\" mm->sm_priv %x in\r\nfifo_init_mm\r\n\",mm->sm_priv); return 0; } /  (3)_fifo_map_swappable:\r\nAccording FIFO PRA, we should link the most recent arrival page at the back of\r\npra_list_head qeueue / static int _fifo_map_swappable(struct mm_struct mm,\r\nuintptr_t addr, struct Page page, int swap_in) { list_entry_t\r\nhead=(list_entry_t) mm->sm_priv; list_entry_t entry=&(page->pra_page_link);\r\nassert(entry != NULL && head != NULL); //record the page access situlation\r\n/LAB3 EXERCISE 2: YOUR CODE/ //(1)link the most recent arrival page at the\r\nback of the pra_list_head qeueue. ===Your code 2=== return 0; } / \r\n(4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the earliest\r\narrival page in front of pra_list_head qeueue,  then set the addr of addr of\r\nthis page to ptr_page. / static int _fifo_swap_out_victim(struct mm_struct\r\nmm, struct Page  ptr_page, int in_tick) { list_entry_t\r\nhead=(list_entry_t) mm->sm_priv; assert(head != NULL); assert(in_tick==0);\r\n/ Select the victim / /LAB3 EXERCISE 2: YOUR CODE/ //(1) unlink the\r\nearliest arrival page in front of pra_list_head qeueue //(2) set the addr of\r\naddr of this page to ptr_page / Select the tail / ===Your code 3=== return\r\n0; } static int _fifo_check_swap(void) { cprintf(\"write Virt Page c in\r\nfifo_check_swap\r\n\"); (unsigned char )0x3000 = 0x0c; assert(pgfault_num==4);\r\ncprintf(\"write Virt Page a in fifo_check_swap\r\n\"); (unsigned char )0x1000 =\r\n0x0a; assert(pgfault_num==4); cprintf(\"write Virt Page d in\r\nfifo_check_swap\r\n\"); (unsigned char )0x4000 = 0x0d; assert(pgfault_num==4);\r\ncprintf(\"write Virt Page b in fifo_check_swap\r\n\"); (unsigned char )0x2000 =\r\n0x0b; assert(pgfault_num==4); cprintf(\"write Virt Page e in\r\nfifo_check_swap\r\n\"); (unsigned char )0x5000 = 0x0e; assert(pgfault_num==5);\r\ncprintf(\"write Virt Page b in fifo_check_swap\r\n\"); (unsigned char )0x2000 =\r\n0x0b; assert(pgfault_num==5); cprintf(\"write Virt Page a in\r\nfifo_check_swap\r\n\"); (unsigned char )0x1000 = 0x0a; assert(pgfault_num==6);\r\ncprintf(\"write Virt Page b in fifo_check_swap\r\n\"); (unsigned char )0x2000 =\r\n0x0b; assert(pgfault_num==7); cprintf(\"write Virt Page c in\r\nfifo_check_swap\r\n\"); (unsigned char )0x3000 = 0x0c; assert(pgfault_num==8);\r\ncprintf(\"write Virt Page d in fifo_check_swap\r\n\"); (unsigned char )0x4000 =\r\n0x0d; assert(pgfault_num==9); return 0; } static int _fifo_init(void) { return\r\n0; } static int _fifo_set_unswappable(struct mm_struct mm, uintptr_t addr) {\r\nreturn 0; } static int _fifo_tick_event(struct mm_struct mm) { return 0; }\r\nstruct swap_manager swap_manager_fifo = { .name = \"fifo swap manager\", .init =\r\n&_fifo_init, .init_mm = &_fifo_init_mm, .tick_event = &_fifo_tick_event,\r\n.map_swappable = &_fifo_map_swappable, .set_unswappable =\r\n&_fifo_set_unswappable, .swap_out_victim = &_fifo_swap_out_victim, .check_swap\r\n= &_fifo_check_swap, }; \"", "degree_of_difficulty": "1", "source": "网络", "answer": "算法：（4分）占用页面按置换时间先后排序；缺页时置换最先进入内存的页面； 实现： map_swappable() //record the page", "type": "question_answer", "options": " a new entry  @listelm: list head to add after  @elm: new entry to be\r\n  \r\n"}