{"knowledge": "中断、异常与系统调用。", "question": "1）系统调用接口是操作系统内核向用户进程提供操作系统服务的接口。试描述用户进程通过系统调用使用操作系统服务的过程。2）gettime_msec是一个获取当前\r\n系统时间的系统调用。请补全该系统调用的实现代码。\r\n    ```\r\n\t    =============libs-user-ucore/ulib.c=============\r\n\t    unsigned int\r\n\t    gettime_msec(void) {\r\n\t        return (unsigned int)sys_gettime();\r\n\t    }\r\n\t    =============libs-user-ucore/syscall.c=============\r\n\t    size_t\r\n\t    sys_gettime(void) {\r\n\t        return (size_t) _--YOUR CODE 4--_;\r\n\t    }\r\n\t    =============libs-user-ucore/arch/i386/syscall.c=============\r\n\t    #define MAX_ARGS            5\r\n\t    uint32_t\r\n\t    syscall(int num, ...) {\r\n\t        va_list ap;\r\n\t        va_start(ap, num);\r\n\t        uint32_t a[MAX_ARGS];\r\n\t        int i;\r\n\t        for (i = 0; i < MAX_ARGS; i ++) {\r\n\t            a[i] = va_arg(ap, uint32_t);\r\n\t        }\r\n\t        va_end(ap);\r\n\t        uint32_t ret;\r\n\t        asm volatile (\r\n\t            \"int %1;\"\r\n\t            : \"=a\" (ret)\r\n\t            : \"i\" (T_SYSCALL),\r\n\t              \"a\" (num),\r\n\t              \"d\" (a[0]),\r\n\t              \"c\" (a[1]),\r\n\t              \"b\" (a[2]),\r\n\t              \"D\" (a[3]),\r\n\t              \"S\" (a[4])\r\n\t            : \"cc\", \"memory\");\r\n\t        return ret;\r\n\t    }\r\n\t    =============libs-user-ucore/common/unistd.h=============\r\n\t    / syscall number /\r\n\t    #define SYS_exit            1\r\n\t    #define SYS_fork            2\r\n\t    #define SYS_wait            3\r\n\t    #define SYS_exec            4\r\n\t    #define SYS_clone           5\r\n\t    #define SYS_exit_thread     9\r\n\t    #define SYS_yield           10\r\n\t    #define SYS_sleep           11\r\n\t    #define SYS_kill            12\r\n\t    #define SYS_gettime         17\r\n\t    #define SYS_getpid          18\r\n\t    #define SYS_brk             19\r\n\t    ……\r\n\t    =============kern-ucore/arch/i386/glue-ucore/trap.c=============\r\n\t    static void\r\n\t    trap_dispatch(struct trapframe tf) {\r\n\t        char c;\r\n\t        int ret;\r\n\t        switch (tf->tf_trapno) {\r\n\t        case T_DEBUG:\r\n\t        case T_BRKPT:\r\n\t            debug_monitor(tf);\r\n\t            break;\r\n\t        case T_PGFLT:\r\n\t            if ((ret = pgfault_handler(tf)) != 0) {\r\n\t                print_trapframe(tf);\r\n\t                if (pls_read(current) == NULL) {\r\n\t                    panic(\"handle pgfault failed. %e\r\n\t\", ret);\r\n\t                }\r\n\t                else {\r\n\t                    if (trap_in_kernel(tf)) {\r\n\t                        panic(\"handle pgfault failed in kernel mode. %e\r\n\t\", ret);\r\n\t                    }\r\n\t                    kprintf(\"killed by kernel.\r\n\t\");\r\n\t                    do_exit(-E_KILLED);\r\n\t                }\r\n\t            }\r\n\t            break;\r\n\t        case T_SYSCALL:\r\n\t            _--YOUR CODE 5--_;\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_TIMER:\r\n\t            ticks ++;\r\n\t            assert(pls_read(current) != NULL);\r\n\t            run_timer_list();\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_COM1:\r\n\t        case IRQ_OFFSET + IRQ_KBD:\r\n\t            if ((c = cons_getc()) == 13) {\r\n\t                debug_monitor(tf);\r\n\t            }\r\n\t            else {\r\n\t                extern void dev_stdin_write(char c);\r\n\t                dev_stdin_write(c);\r\n\t            }\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_IDE1:\r\n\t        case IRQ_OFFSET + IRQ_IDE2:\r\n\t            / do nothing /\r\n\t            break;\r\n\t        default:\r\n\t            print_trapframe(tf);\r\n\t            if (pls_read(current) != NULL) {\r\n\t                kprintf(\"unhandled trap.\r\n\t\");\r\n\t                do_exit(-E_KILLED);\r\n\t            }\r\n\t            panic(\"unexpected trap in kernel.\r\n\t\");\r\n\t        }\r\n\t    }\r\n\t    void\r\n\t    trap(struct trapframe tf) {\r\n\t        // used for previous projects\r\n\t        if (pls_read(current) == NULL) {\r\n\t            trap_dispatch(tf);\r\n\t        }\r\n\t        else {\r\n\t            // keep a trapframe chain in stack\r\n\t            struct trapframe otf = pls_read(current)->tf;\r\n\t            pls_read(current)->tf = tf;\r\n\t            bool in_kernel = trap_in_kernel(tf);\r\n\t            _--YOUR CODE 6--_;\r\n\t            pls_read(current)->tf = otf;\r\n\t            if (!in_kernel) {\r\n\t                may_killed();\r\n\t                if (pls_read(current)->need_resched) {\r\n\t                    schedule();\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    =============kern-ucore/arch/i386/syscall/syscall.c=============\r\n\t    ……\r\n\t    static uint32_t\r\n\t    sys_gettime(uint32_t arg[]) {\r\n\t        return (int)ticks;\r\n\t    }\r\n\t    ……\r\n\t    static uint32_t (syscalls[])(uint32_t arg[]) = {\r\n\t        [SYS_exit]              sys_exit,\r\n\t        [SYS_fork]              sys_fork,\r\n\t        [SYS_wait]              sys_wait,\r\n\t        [SYS_exec]              sys_exec,\r\n\t        [SYS_clone]             sys_clone,\r\n\t        [SYS_exit_thread]       sys_exit_thread,\r\n\t        [SYS_yield]             sys_yield,\r\n\t        [SYS_kill]              sys_kill,\r\n\t        [SYS_sleep]             sys_sleep,\r\n\t        [SYS_gettime]           _--YOUR CODE 7--_,\r\n\t        [SYS_getpid]            sys_getpid,\r\n\t    ……\r\n\t    };\r\n\t    #define NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))\r\n\t    void\r\n\t    syscall(void) {\r\n\t        struct trapframe tf = pls_read(current)->tf;\r\n\t        uint32_t arg[5];\r\n\t        int num = tf->tf_regs.reg_eax;\r\n\t        if (num >= 0 && num < NUM_SYSCALLS) {\r\n\t            if (syscalls[num] != NULL) {\r\n\t                arg[0] = tf->tf_regs.reg_edx;\r\n\t                arg[1] = tf->tf_regs.reg_ecx;\r\n\t                arg[2] = tf->tf_regs.reg_ebx;\r\n\t                arg[3] = tf->tf_regs.reg_edi;\r\n\t                arg[4] = tf->tf_regs.reg_esi;\r\n\t                tf->tf_regs.reg_eax = _--YOUR CODE 8--_;\r\n\t                return ;\r\n\t            }\r\n\t        }\r\n\t        print_trapframe(tf);\r\n\t        panic(\"undefined syscall %d, pid = %d, name = %s.\r\n\t\",\r\n\t                num, pls_read(current)->pid, pls_read(current)->name);\r\n\t    }\r\n\t    ```", "degree_of_difficulty": "1", "source": "网络", "answer": "1）系统调用的过程：（8分，每个关键词1分）", "type": "question_answer", "options": "  \r\n"}