{"knowledge": "中断、异常与系统调用。", "question": "调度算法：\r\n     第三题：\r\n    一、   (18分)调度器是操作系统内核中依据调度算法进行进程切换选择的模块。1）试描述时间片轮转算法（Round Robin）的基本原理。2）下面代码是ucore中调度器和时间片轮转算法的实现代码。请补全其中所缺代码，以实现调度器和调度算法的功能。提示：每处需要补全的代码只需要一行，一共有7个空要填。\r\n    ```\r\n\t    sched.h\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    struct proc_struct;\r\n\t    typedef struct {\r\n\t      unsigned int expires;\r\n\t      struct proc_struct proc;\r\n\t      list_entry_t timer_link;\r\n\t    } timer_t;\r\n\t    #define le2timer(le, member)      \\\r\n\t      to_struct((le), timer_t, member)\r\n\t    static inline timer_t \r\n\t    timer_init(timer_t timer, struct proc_struct proc, int expires) {\r\n\t      timer->expires = expires;\r\n\t      timer->proc = proc;\r\n\t      list_init(&(timer->timer_link));\r\n\t      return timer;\r\n\t    }\r\n\t    struct run_queue;\r\n\t    struct sched_class {\r\n\t      const char name;\r\n\t      void (init)(struct run_queue rq);\r\n\t      void (enqueue)(struct run_queue rq, struct proc_struct proc);\r\n\t      void (dequeue)(struct run_queue rq, struct proc_struct proc);\r\n\t      struct proc_struct (pick_next)(struct run_queue rq);\r\n\t      void (proc_tick)(struct run_queue rq, struct proc_struct proc);\r\n\t    };\r\n\t    struct run_queue {\r\n\t      list_entry_t run_list;\r\n\t      unsigned int proc_num;\r\n\t      int max_time_slice;\r\n\t      list_entry_t rq_link;\r\n\t    };\r\n\t    #define le2rq(le, member)     \\\r\n\t      to_struct((le), struct run_queue, member)\r\n\t    void sched_init(void);\r\n\t    void wakeup_proc(struct proc_struct proc);\r\n\t    void schedule(void);\r\n\t    void add_timer(timer_t timer);\r\n\t    void del_timer(timer_t timer);\r\n\t    void run_timer_list(void);\r\n\t    extern struct proc_struct idleproc, initproc, current;\r\n\t    extern struct proc_struct kswapd;\r\n\t    …\r\n\t    -----------------------------------------------\r\n\t    sched.c\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    static list_entry_t timer_list;\r\n\t    static struct sched_class sched_class;\r\n\t    static struct run_queue rq;\r\n\t    static inline void\r\n\t    sched_class_enqueue(struct proc_struct proc) {\r\n\t      if (proc != idleproc) {\r\n\t        sched_class->enqueue(rq, proc);\r\n\t      }\r\n\t    }\r\n\t    static inline void\r\n\t    sched_class_dequeue(struct proc_struct proc) {\r\n\t      sched_class->dequeue(rq, proc);\r\n\t    }\r\n\t    static inline struct proc_struct \r\n\t    sched_class_pick_next(void) {\r\n\t      return sched_class->pick_next(rq);\r\n\t    }\r\n\t    static void\r\n\t    sched_class_proc_tick(struct proc_struct proc) {\r\n\t      if (proc != idleproc) {\r\n\t        sched_class->proc_tick(rq, proc);\r\n\t      }\r\n\t      else {\r\n\t        proc->need_resched = 1;\r\n\t      }\r\n\t    }\r\n\t    static struct run_queue __rq[4];\r\n\t    void\r\n\t    sched_init(void) {\r\n\t      list_init(&timer;_list);\r\n\t      rq = __rq;\r\n\t      list_init(&(rq->rq_link));\r\n\t      rq->max_time_slice = 8;\r\n\t      int i;\r\n\t      for (i = 1; i < sizeof(__rq) / sizeof(__rq[0]); i ++) {\r\n\t        list_add_before(&(rq->rq_link), &(__rq[i].rq_link));\r\n\t        __rq[i].max_time_slice = rq->max_time_slice  (1 << i);\r\n\t      }\r\n\t      sched_class = &MLFQ;_sched_class;\r\n\t      sched_class->init(rq);\r\n\t      cprintf(\"sched class: %s\r\n\t\", sched_class->name);\r\n\t    }\r\n\t    void\r\n\t    wakeup_proc(struct proc_struct proc) {\r\n\t      assert(proc->state != PROC_ZOMBIE);\r\n\t      bool intr_flag;\r\n\t      local_intr_save(intr_flag);\r\n\t      {\r\n\t        if (proc->state != PROC_RUNNABLE) {\r\n\t          proc->state = PROC_RUNNABLE;\r\n\t          proc->wait_state = 0;\r\n\t          sched_class_enqueue(proc);\r\n\t        }\r\n\t        else {\r\n\t          warn(\"wakeup runnable process.\r\n\t\");\r\n\t        }\r\n\t      }\r\n\t      local_intr_restore(intr_flag);\r\n\t    }\r\n\t    void\r\n\t    schedule(void) {\r\n\t      bool intr_flag;\r\n\t      struct proc_struct next;\r\n\t      local_intr_save(intr_flag);\r\n\t      {\r\n\t        current->need_resched = 0;\r\n\t        if (current->state == PROC_RUNNABLE) {\r\n\t          ...(1)...\r\n\t        }\r\n\t        if ((next = sched_class_pick_next()) != NULL) {\r\n\t          ...(2)...\r\n\t        }\r\n\t      }\r\n\t      local_intr_restore(intr_flag);\r\n\t      if (next == NULL) {\r\n\t        next = ...(3)...;\r\n\t      }\r\n\t      next->runs ++;\r\n\t      if (next != current) {\r\n\t        ...(4)...\r\n\t      }\r\n\t    }\r\n\t    …\r\n\t    -----------------------------------------------\r\n\t    sched_RR.c\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    static void\r\n\t    RR_init(struct run_queue rq) {\r\n\t      list_init(&(rq->run_list));\r\n\t      rq->proc_num = 0;\r\n\t    }\r\n\t    static void\r\n\t    RR_enqueue(struct run_queue rq, struct proc_struct proc) {\r\n\t      assert(list_empty(&(proc->run_link)));\r\n\t      list_add_before(&(rq->run_list), &(proc->run_link));\r\n\t      if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {\r\n\t        ...(5)...\r\n\t      }\r\n\t      proc->rq = rq;\r\n\t      rq->proc_num ++;\r\n\t    }\r\n\t    static void\r\n\t    RR_dequeue(struct run_queue rq, struct proc_struct proc) {\r\n\t      assert(!list_empty(&(proc->run_link)) && proc->rq == rq);\r\n\t      list_del_init(&(proc->run_link));\r\n\t      rq->proc_num --;\r\n\t    }\r\n\t    static struct proc_struct \r\n\t    RR_pick_next(struct run_queue rq) {\r\n\t      list_entry_t le = list_next(&(rq->run_list));\r\n\t      if (le != &(rq->run_list)) {\r\n\t        return le2proc(le, run_link);\r\n\t      }\r\n\t      return NULL;\r\n\t    }\r\n\t    static void\r\n\t    RR_proc_tick(struct run_queue rq, struct proc_struct proc) {\r\n\t      if (proc->time_slice > 0) {\r\n\t        ...(6)...\r\n\t      }\r\n\t      if (proc->time_slice == 0) {\r\n\t        ...(7)...\r\n\t      }\r\n\t    }\r\n\t    struct sched_class RR_sched_class = {\r\n\t      .name = \"RR_scheduler\",\r\n\t      .init = RR_init,\r\n\t      .enqueue = RR_enqueue,\r\n\t      .dequeue = RR_dequeue,\r\n\t      .pick_next = RR_pick_next,\r\n\t      .proc_tick = RR_proc_tick,\r\n\t    };\r\n\t    -----------------------------------------------\r\n\t    proc.c\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    // proc_run - make process \"proc\" running on cpu\r\n\t    // NOTE: before call switch_to, should load  base addr of \"proc\"'s new PDT\r\n\t    void\r\n\t    proc_run(struct proc_struct proc) {\r\n\t        if (proc != current) {\r\n\t            bool intr_flag;\r\n\t            struct proc_struct prev = current, next = proc;\r\n\t            local_intr_save(intr_flag);\r\n\t            {\r\n\t                current = proc;\r\n\t                load_esp0(next->kstack + KSTACKSIZE);\r\n\t                lcr3(next->cr3);\r\n\t                switch_to(&(prev->context), &(next->context));\r\n\t            }\r\n\t            local_intr_restore(intr_flag);\r\n\t        }\r\n\t    }\r\n\t    …\r\n\t    -----------------------------------------------\r\n\t    ```", "degree_of_difficulty": "1", "source": "网络", "answer": "解释", "type": "question_answer", "options": "  \r\n"}