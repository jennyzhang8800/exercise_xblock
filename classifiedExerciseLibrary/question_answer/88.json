{"knowledge": "实验环境准备实验。", "question": "6.fork程序输出 一、 (10分)给出程序fork.c的输出结果。注：（c1）getpid()和getppid()是两个系统调用，分别返回本进程标识和父\r\n进程标识。（2）你可以假定每次新进程创建时生成的进程标识是顺序加1得到的，该程序执行时创建的第一个进程的标识为1000。\r\n,\r\n    ```\r\n\t    fork.c\r\n\t    ----------------------\r\n\t    / Includes /\r\n\t    #include      / Symbolic Constants /\r\n\t    #include   / Primitive System Data Types /\r\n\t    #include       / Errors /\r\n\t    #include       / Input/Output /\r\n\t    #include    / Wait for Process Termination /\r\n\t    #include      / General Utilities /\r\n\t    int main()\r\n\t    {\r\n\t        pid_t childpid; / variable to store the child's pid /\r\n\t        int retval;     / child process: user-provided return code /\r\n\t        int status;     / parent process: child's exit status /\r\n\t        / only 1 int variable is needed because each process would have its\r\n\t           own instance of the variable\r\n\t           here, 2 int variables are used for clarity /\r\n\t        / now create new process /\r\n\t        childpid = fork();\r\n\t        if (childpid >= 0) / fork succeeded /\r\n\t        {\r\n\t            if (childpid == 0) / fork() returns 0 to the child process /\r\n\t            {\r\n\t                printf(\"CHILD: I am the child process!\r\n\t\");\r\n\t                printf(\"CHILD: Here's my PID: %d\r\n\t\", getpid());\r\n\t                printf(\"CHILD: My parent's PID is: %d\r\n\t\", getppid());\r\n\t                printf(\"CHILD: The value of my copy of childpid is: %d\r\n\t\", childpid);\r\n\t                printf(\"CHILD: Sleeping for 1 second...\r\n\t\");\r\n\t                sleep(1); / sleep for 1 second /\r\n\t                printf(\"CHILD: Enter an exit value (0 to 255): \");\r\n\t                scanf(\" %d\", &retval;);\r\n\t                printf(\"CHILD: Goodbye!\r\n\t\");\r\n\t                exit(retval); / child exits with user-provided return code /\r\n\t            }\r\n\t            else / fork() returns new pid to the parent process /\r\n\t            {\r\n\t                printf(\"PARENT: I am the parent process!\r\n\t\");\r\n\t                printf(\"PARENT: Here's my PID: %d\r\n\t\", getpid());\r\n\t                printf(\"PARENT: The value of my copy of childpid is %d\r\n\t\", childpid);\r\n\t                printf(\"PARENT: I will now wait for my child to exit.\r\n\t\");\r\n\t                wait(&status;); / wait for child to exit, and store its status /\r\n\t                printf(\"PARENT: Child's exit code is: %d\r\n\t\", WEXITSTATUS(status));\r\n\t                printf(\"PARENT: Goodbye!\r\n\t\");\r\n\t                exit(0);  / parent exits /\r\n\t            }\r\n\t        }\r\n\t        else / fork returns -1 on failure /\r\n\t        {\r\n\t            perror(\"fork\"); / display error message /\r\n\t            exit(0);\r\n\t        }\r\n\t    }\r\n\t    ```", "degree_of_difficulty": "1", "source": "网络", "answer": "解释", "type": "question_answer", "options": "  \r\n"}