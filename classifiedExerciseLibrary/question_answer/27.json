{"knowledge": "处理机调度。", "question": "(18分)调度器是操作系统内核中依据调度算法进行进程切换选择的模块。\r\n1）试描述步进调度算法(Stride Scheduling)的基本原理。\r\n2）请补全下面 ucore代码中调度器和步进调度算法实现中所缺代码，以实现调度器和调度算法的功能。提示：每处需要补全的代码最少只需要一行，一共有9个空要填。\r\n当然，你可以在需要补全代码的地方写多行来表达需要实现的功能，也允许修改已给出的代码。\r\n3）试描述斜堆(skew heap)在这个步进调度算法中的作用。\r\n    ```\r\n\t    kern/process/proc.h\r\n\t    ==================== kern/process/proc.h ========================\r\n\t    #ifndef __KERN_PROCESS_PROC_H__\r\n\t    #define __KERN_PROCESS_PROC_H__\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    // process's state in his life cycle\r\n\t    enum proc_state {\r\n\t        PROC_UNINIT = 0,  // uninitialized\r\n\t        PROC_SLEEPING,    // sleeping\r\n\t        PROC_RUNNABLE,    // runnable(maybe running)\r\n\t        PROC_ZOMBIE,      // almost dead, and wait parent proc to reclaim his resource\r\n\t    };\r\n\t    // Saved registers for kernel context switches.\r\n\t    // Don't need to save all the %fs etc. segment registers,\r\n\t    // because they are constant across kernel contexts.\r\n\t    // Save all the regular registers so we don't need to care\r\n\t    // which are caller save, but not the return register %eax.\r\n\t    // (Not saving %eax just simplifies the switching code.)\r\n\t    // The layout of context must match code in switch.S.\r\n\t    struct context {\r\n\t        uint32_t eip;\r\n\t        uint32_t esp;\r\n\t        uint32_t ebx;\r\n\t        uint32_t ecx;\r\n\t        uint32_t edx;\r\n\t        uint32_t esi;\r\n\t        uint32_t edi;\r\n\t        uint32_t ebp;\r\n\t    };\r\n\t    #define PROC_NAME_LEN               15\r\n\t    #define MAX_PROCESS                 4096\r\n\t    #define MAX_PID                     (MAX_PROCESS  2)\r\n\t    extern list_entry_t proc_list;\r\n\t    struct proc_struct {\r\n\t        enum proc_state state;                      // Process state\r\n\t        int pid;                                    // Process ID\r\n\t        int runs;                                   // the running times of Proces\r\n\t        uintptr_t kstack;                           // Process kernel stack\r\n\t        volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?\r\n\t        struct proc_struct parent;                 // the parent process\r\n\t        struct mm_struct mm;                       // Process's memory management field\r\n\t        struct context context;                     // Switch here to run process\r\n\t        struct trapframe tf;                       // Trap frame for current interrupt\r\n\t        uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)\r\n\t        uint32_t flags;                             // Process flag\r\n\t        char name[PROC_NAME_LEN + 1];               // Process name\r\n\t        list_entry_t list_link;                     // Process link list\r\n\t        list_entry_t hash_link;                     // Process hash list\r\n\t        int exit_code;                              // exit code (be sent to parent proc)\r\n\t        uint32_t wait_state;                        // waiting state\r\n\t        struct proc_struct cptr, yptr, optr;     // relations between processes\r\n\t        struct run_queue rq;                       // running queue contains Process\r\n\t        list_entry_t run_link;                      // the entry linked in run queue\r\n\t        int time_slice;                             // time slice for occupying the CPU\r\n\t        skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool\r\n\t        uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process\r\n\t        uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)\r\n\t    };\r\n\t    #define PF_EXITING                  0x00000001      // getting shutdown\r\n\t    #define WT_CHILD                    (0x00000001 | WT_INTERRUPTED)\r\n\t    #define WT_INTERRUPTED               0x80000000                    // the wait state could be interrupted\r\n\t    #define le2proc(le, member)         \\\r\n\t        to_struct((le), struct proc_struct, member)\r\n\t    extern struct proc_struct idleproc, initproc, current;\r\n\t    void proc_init(void);\r\n\t    void proc_run(struct proc_struct proc);\r\n\t    int kernel_thread(int (fn)(void ), void arg, uint32_t clone_flags);\r\n\t    char set_proc_name(struct proc_struct proc, const char name);\r\n\t    char get_proc_name(struct proc_struct proc);\r\n\t    void cpu_idle(void) __attribute__((noreturn));\r\n\t    struct proc_struct find_proc(int pid);\r\n\t    int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe tf);\r\n\t    int do_exit(int error_code);\r\n\t    int do_yield(void);\r\n\t    int do_execve(const char name, size_t len, unsigned char binary, size_t size);\r\n\t    int do_wait(int pid, int code_store);\r\n\t    int do_kill(int pid);\r\n\t    void lab6_set_priority(uint32_t priority);\r\n\t    #endif / !__KERN_PROCESS_PROC_H__ /\r\n\t    =============================================================\r\n\t    kern/schedule/default_sched.c\r\n\t    =============kern/schedule/default_sched.c========================\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #define USE_SKEW_HEAP 1\r\n\t    / You should define the BigStride constant here/\r\n\t    / LAB6: YOUR CODE /\r\n\t    #define BIG_STRIDE    0x7FFFFFFF / ??? /\r\n\t    / The compare function for two skew_heap_node_t's and the\r\n\t      corresponding procs/\r\n\t    static int\r\n\t    proc_stride_comp_f(void a, void b)\r\n\t    {\r\n\t         struct proc_struct p = le2proc(a, lab6_run_pool);\r\n\t         struct proc_struct q = le2proc(b, lab6_run_pool);\r\n\t         int32_t c = p->lab6_stride - q->lab6_stride;\r\n\t         if (c > 0) return 1;\r\n\t         else if (c == 0) return 0;\r\n\t         else return -1;\r\n\t    }\r\n\t    /\r\n\t      stride_init initializes the run-queue rq with correct assignment for\r\n\t      member variables, including:\r\n\t     \r\n\t        - run_list: should be a empty list after initialization.\r\n\t        - lab6_run_pool: NULL\r\n\t        - proc_num: 0\r\n\t        - max_time_slice: no need here, the variable would be assigned by the caller.\r\n\t     \r\n\t      hint: see proj13.1/libs/list.h for routines of the list structures.\r\n\t     /\r\n\t    static void\r\n\t    stride_init(struct run_queue rq) {\r\n\t         / LAB6: YOUR CODE /\r\n\t         list_init(&(rq->run_list));\r\n\t         rq->lab6_run_pool = NULL;\r\n\t         rq->proc_num = 0;\r\n\t    }\r\n\t    /\r\n\t      stride_enqueue inserts the process ``proc'' into the run-queue\r\n\t      ``rq''. The procedure should verify/initialize the relevant members\r\n\t      of ``proc'', and then put the ``lab6_run_pool'' node into the\r\n\t      queue(since we use priority queue here). The procedure should also\r\n\t      update the meta date in ``rq'' structure.\r\n\t     \r\n\t      proc->time_slice denotes the time slices allocation for the\r\n\t      process, which should set to rq->max_time_slice.\r\n\t     \r\n\t      hint: see proj13.1/libs/skew_heap.h for routines of the priority\r\n\t      queue structures.\r\n\t     /\r\n\t    static void\r\n\t    stride_enqueue(struct run_queue rq, struct proc_struct proc) {\r\n\t         / LAB6: YOUR CODE /\r\n\t    #if USE_SKEW_HEAP\r\n\t         rq->lab6_run_pool = ……(1)……;\r\n\t    #else\r\n\t         assert(list_empty(&(proc->run_link)));\r\n\t         list_add_before(&(rq->run_list), &(proc->run_link));\r\n\t    #endif\r\n\t         if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {\r\n\t              proc->time_slice = rq->max_time_slice;\r\n\t         }\r\n\t         proc->rq = rq;\r\n\t         rq->proc_num ++;\r\n\t    }\r\n\t    /\r\n\t      stride_dequeue removes the process ``proc'' from the run-queue\r\n\t      ``rq'', the operation would be finished by the skew_heap_remove\r\n\t      operations. Remember to update the ``rq'' structure.\r\n\t     \r\n\t      hint: see proj13.1/libs/skew_heap.h for routines of the priority\r\n\t      queue structures.\r\n\t     /\r\n\t    static void\r\n\t    stride_dequeue(struct run_queue rq, struct proc_struct proc) {\r\n\t         / LAB6: YOUR CODE /\r\n\t    #if USE_SKEW_HEAP\r\n\t         rq->lab6_run_pool =  ……(2)……;\r\n\t    #else\r\n\t         assert(!list_empty(&(proc->run_link)) && proc->rq == rq);\r\n\t         list_del_init(&(proc->run_link));\r\n\t    #endif\r\n\t         rq->proc_num --;\r\n\t    }\r\n\t    /\r\n\t      stride_pick_next pick the element from the ``run-queue'', with the\r\n\t      minimum value of stride, and returns the corresponding process\r\n\t      pointer. The process pointer would be calculated by macro le2proc,\r\n\t      see proj13.1/kern/process/proc.h for definition. Return NULL if\r\n\t      there is no process in the queue.\r\n\t     \r\n\t      When one proc structure is selected, remember to update the stride\r\n\t      property of the proc. (stride += BIG_STRIDE / priority)\r\n\t     \r\n\t      hint: see proj13.1/libs/skew_heap.h for routines of the priority\r\n\t      queue structures.\r\n\t     /\r\n\t    static struct proc_struct \r\n\t    stride_pick_next(struct run_queue rq) {\r\n\t         / LAB6: YOUR CODE /\r\n\t    #if USE_SKEW_HEAP\r\n\t         if (rq->lab6_run_pool == NULL) return NULL;\r\n\t         struct proc_struct p = le2proc(rq->lab6_run_pool, lab6_run_pool);\r\n\t    #else\r\n\t         list_entry_t le = list_next(&(rq->run_list));\r\n\t         if (le == &rq-;>run_list)\r\n\t              return NULL;\r\n\t         struct proc_struct p = le2proc(le, run_link);\r\n\t         le = list_next(le);\r\n\t         while (le != &rq-;>run_list)\r\n\t         {\r\n\t              struct proc_struct q = le2proc(le, run_link);\r\n\t              if ((int32_t)(p->lab6_stride - q->lab6_stride) > 0)\r\n\t                   p = q;\r\n\t              le = list_next(le);\r\n\t         }\r\n\t    #endif\r\n\t         if (p->lab6_priority == 0)\r\n\t              p->lab6_stride += BIG_STRIDE;\r\n\t         else p->lab6_stride = ……(3)……;\r\n\t         return p;\r\n\t    }\r\n\t    /\r\n\t      stride_proc_tick works with the tick event of current process. You\r\n\t      should check whether the time slices for current process is\r\n\t      exhausted and update the proc struct ``proc''. proc->time_slice\r\n\t      denotes the time slices left for current\r\n\t      process. proc->need_resched is the flag variable for process\r\n\t      switching.\r\n\t     /\r\n\t    static void\r\n\t    stride_proc_tick(struct run_queue rq, struct proc_struct proc) {\r\n\t         / LAB6: YOUR CODE /\r\n\t         if (proc->time_slice > 0) {\r\n\t              ……(4)……;\r\n\t         }\r\n\t         if (proc->time_slice == 0) {\r\n\t              ……(5)……;\r\n\t         }\r\n\t    }\r\n\t    struct sched_class default_sched_class = {\r\n\t         .name = \"stride_scheduler\",\r\n\t         .init = stride_init,\r\n\t         .enqueue = ……(6)……,\r\n\t         .dequeue = ……(7)……,\r\n\t         .pick_next = ……(8)……,\r\n\t         .proc_tick = ……(9)……,\r\n\t    };\r\n\t    =============================================================\r\n\t    libs/skew_heap.h\r\n\t    ====================libs/skew_heap.h============================\r\n\t    #ifndef __LIBS_SKEW_HEAP_H__\r\n\t    #define __LIBS_SKEW_HEAP_H__\r\n\t    struct skew_heap_entry {\r\n\t         struct skew_heap_entry parent, left, right;\r\n\t    };\r\n\t    typedef struct skew_heap_entry skew_heap_entry_t;\r\n\t    typedef int(compare_f)(void a, void b);\r\n\t    static inline void skew_heap_init(skew_heap_entry_t a) __attribute__((always_inline));\r\n\t    static inline skew_heap_entry_t skew_heap_merge(\r\n\t         skew_heap_entry_t a, skew_heap_entry_t b,\r\n\t         compare_f comp);\r\n\t    static inline skew_heap_entry_t skew_heap_insert(\r\n\t         skew_heap_entry_t a, skew_heap_entry_t b,\r\n\t         compare_f comp) __attribute__((always_inline));\r\n\t    static inline skew_heap_entry_t skew_heap_remove(\r\n\t         skew_heap_entry_t a, skew_heap_entry_t b,\r\n\t         compare_f comp) __attribute__((always_inline));\r\n\t    static inline void\r\n\t    skew_heap_init(skew_heap_entry_t a)\r\n\t    {\r\n\t         a->left = a->right = a->parent = NULL;\r\n\t    }\r\n\t    static inline skew_heap_entry_t \r\n\t    skew_heap_merge(skew_heap_entry_t a, skew_heap_entry_t b,\r\n\t                    compare_f comp)\r\n\t    {\r\n\t         if (a == NULL) return b;\r\n\t         else if (b == NULL) return a;\r\n\t         skew_heap_entry_t l, r;\r\n\t         if (comp(a, b) == -1)\r\n\t         {\r\n\t              r = a->left;\r\n\t              l = skew_heap_merge(a->right, b, comp);\r\n\t              a->left = l;\r\n\t              a->right = r;\r\n\t              if (l) l->parent = a;\r\n\t              return a;\r\n\t         }\r\n\t         else\r\n\t         {\r\n\t              r = b->left;\r\n\t              l = skew_heap_merge(a, b->right, comp);\r\n\t              b->left = l;\r\n\t              b->right = r;\r\n\t              if (l) l->parent = b;\r\n\t              return b;\r\n\t         }\r\n\t    }\r\n\t    static inline skew_heap_entry_t \r\n\t    skew_heap_insert(skew_heap_entry_t a, skew_heap_entry_t b,\r\n\t                     compare_f comp)\r\n\t    {\r\n\t         skew_heap_init(b);\r\n\t         return skew_heap_merge(a, b, comp);\r\n\t    }\r\n\t    static inline skew_heap_entry_t \r\n\t    skew_heap_remove(skew_heap_entry_t a, skew_heap_entry_t b,\r\n\t                     compare_f comp)\r\n\t    {\r\n\t         skew_heap_entry_t p   = b->parent;\r\n\t         skew_heap_entry_t rep = skew_heap_merge(b->left, b->right, comp);\r\n\t         if (rep) rep->parent = p;\r\n\t         if (p)\r\n\t         {\r\n\t              if (p->left == b)\r\n\t                   p->left = rep;\r\n\t              else p->right = rep;\r\n\t              return a;\r\n\t         }\r\n\t         else return rep;\r\n\t    }\r\n\t    #endif  / !__LIBS_SKEW_HEAP_H__ /\r\n\t    =============================================================\r\n\t    ```", "degree_of_difficulty": "1", "source": "网络", "answer": "基本原理7分；填空9分；斜堆2分；", "type": "question_answer", "options": "  \r\n"}