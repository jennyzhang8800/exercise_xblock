{"knowledge": "进程状态与控制。", "question": "1）试描述ucore的进程创建系统调用fork（）的基本过程。2）请补全fork系统调用的实现代码。\r\n    ```\r\n\t    =============kern-ucore/process/proc.c=============\r\n\t    // get_pid - alloc a unique pid for process\r\n\t    static int\r\n\t    get_pid(void) {\r\n\t    ……\r\n\t    }\r\n\t    ……\r\n\t    int\r\n\t    do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe tf) {\r\n\t        int ret = -E_NO_FREE_PROC;\r\n\t        struct proc_struct proc;\r\n\t        if (nr_process >= MAX_PROCESS) {\r\n\t            goto fork_out;\r\n\t        }\r\n\t        ret = -E_NO_MEM;\r\n\t        if ((proc = alloc_proc()) == NULL) {\r\n\t            goto fork_out;\r\n\t        }\r\n\t        proc->parent = _--YOUR CODE 13--_;\r\n\t        list_init(&(proc->thread_group));\r\n\t        assert(current->wait_state == 0);\r\n\t        assert(current->time_slice >= 0);\r\n\t        proc->time_slice = current->time_slice / 2;\r\n\t        current->time_slice -= proc->time_slice;\r\n\t        if (setup_kstack(proc) != 0) {\r\n\t            goto bad_fork_cleanup_proc;\r\n\t        }\r\n\t        if (copy_sem(clone_flags, proc) != 0) {\r\n\t            goto bad_fork_cleanup_kstack;\r\n\t        }\r\n\t        if (copy_fs(clone_flags, proc) != 0) {\r\n\t            goto bad_fork_cleanup_sem;\r\n\t        }\r\n\t        if (copy_mm(clone_flags, proc) != 0) {\r\n\t            goto bad_fork_cleanup_fs;\r\n\t        }\r\n\t        if (copy_thread(clone_flags, proc, stack, tf) != 0) {\r\n\t            goto bad_fork_cleanup_sem;\r\n\t        }\r\n\t        bool intr_flag;\r\n\t        local_intr_save(intr_flag);\r\n\t        {\r\n\t            proc->pid = _--YOUR CODE 14--_;\r\n\t            hash_proc(proc);\r\n\t            set_links(proc);\r\n\t            if (clone_flags & CLONE_THREAD) {\r\n\t                list_add_before(&(current->thread_group), &(proc->thread_group));\r\n\t            }\r\n\t        }\r\n\t        local_intr_restore(intr_flag);\r\n\t        wakeup_proc(proc);\r\n\t        ret = _--YOUR CODE 15--_;\r\n\t    fork_out:\r\n\t        return ret;\r\n\t    bad_fork_cleanup_fs:\r\n\t        put_fs(proc);\r\n\t    bad_fork_cleanup_sem:\r\n\t        put_sem_queue(proc);\r\n\t    bad_fork_cleanup_kstack:\r\n\t        put_kstack(proc);\r\n\t    bad_fork_cleanup_proc:\r\n\t        kfree(proc);\r\n\t        goto fork_out;\r\n\t    }\r\n\t    =============kern-ucore/arch/i386/process/proc.c=============\r\n\t    // forkret -- the first kernel entry point of a new thread/process\r\n\t    // NOTE: the addr of forkret is setted in copy_thread function\r\n\t    //       after switch_to, the current proc will execute here.\r\n\t    static void\r\n\t    forkret(void) {\r\n\t        forkrets(pls_read(current)->tf);\r\n\t    }\r\n\t    ……\r\n\t    // copy_thread - setup the trapframe on the  process's kernel stack top and\r\n\t    //             - setup the kernel entry point and stack of process\r\n\t    int\r\n\t    copy_thread(uint32_t clone_flags, struct proc_struct proc,\r\n\t                uintptr_t esp, struct trapframe tf) {\r\n\t        proc->tf = (struct trapframe )(proc->kstack + KSTACKSIZE) - 1;\r\n\t        (proc->tf) = tf;\r\n\t        proc->tf->tf_regs.reg_eax = 0;\r\n\t        proc->tf->tf_esp = esp;\r\n\t        proc->tf->tf_eflags |= FL_IF;\r\n\t        proc->context.eip = (uintptr_t) _--YOUR CODE 16--_;\r\n\t        proc->context.esp = (uintptr_t)(proc->tf);\r\n\t        return 0;\r\n\t    }\r\n\t    ```", "degree_of_difficulty": "1", "source": "网络", "answer": "1）fork()系统调用的执行过程： 进程通过调用fork（）进入内核，在内核完成子进程的复制（2分）后，放入就绪队列；父进程返回子进程的标识（2分）；子进", "type": "question_answer", "options": "  \r\n"}