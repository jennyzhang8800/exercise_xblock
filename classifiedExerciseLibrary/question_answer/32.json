{"knowledge": "文件系统。", "question": "(18分)文件系统是操作系统内核中用于持久保存数据的功能模块。\r\n1）试描述SFS文件系统中的文件存储组织，即文件内部数据块存储位置和顺序的组织方法；\r\n2）试描述ucore文件系统在一个SFS文件的最后附加一个新数据块实现方法；\r\n3）试解释下面 ucore代码中文件系统实现中与append_block()函数相关的指定代码行的作用。注意：需要解释的代码共有12处。\r\n    ```\r\n\t    kern/fs/sfs/sfs.h\r\n\t    ========================kern/fs/sfs/sfs.h========================\r\n\t    #ifndef __KERN_FS_SFS_SFS_H__\r\n\t    #define __KERN_FS_SFS_SFS_H__\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #define SFS_MAGIC            0x2f8dbe2a              / magic number for sfs /\r\n\t    #define SFS_BLKSIZE          PGSIZE                  / size of block /\r\n\t    #define SFS_NDIRECT          12                      / # of direct blocks in inode /\r\n\t    #define SFS_MAX_INFO_LEN     31                      / max length of infomation /\r\n\t    #define SFS_MAX_FNAME_LEN    FS_MAX_FNAME_LEN        / max length of filename /\r\n\t    #define SFS_MAX_FILE_SIZE    (1024UL  1024  128)   / max file size (128M) /\r\n\t    #define SFS_BLKN_SUPER       0                   / block the superblock lives in /\r\n\t    #define SFS_BLKN_ROOT        1                   / location of the root dir inode /\r\n\t    #define SFS_BLKN_FREEMAP     2                   / 1st block of the freemap /\r\n\t    / # of bits in a block /\r\n\t    #define SFS_BLKBITS                                 (SFS_BLKSIZE  CHAR_BIT)\r\n\t    / # of entries in a block /\r\n\t    #define SFS_BLK_NENTRY                              (SFS_BLKSIZE / sizeof(uint32_t))\r\n\t    / file types /\r\n\t    #define SFS_TYPE_INVAL                              0       / Should not appear on disk /\r\n\t    #define SFS_TYPE_FILE                               1\r\n\t    #define SFS_TYPE_DIR                                2\r\n\t    #define SFS_TYPE_LINK                               3\r\n\t    /\r\n\t      On-disk superblock\r\n\t     /\r\n\t    struct sfs_super {\r\n\t        uint32_t magic;                                 / magic number, should be SFS_MAGIC /\r\n\t        uint32_t blocks;                                / # of blocks in fs /\r\n\t        uint32_t unused_blocks;                         / # of unused blocks in fs /\r\n\t        char info[SFS_MAX_INFO_LEN + 1];                / infomation for sfs  /\r\n\t    };\r\n\t    / inode (on disk) /\r\n\t    struct sfs_disk_inode {\r\n\t        uint32_t size;                                  / size of the file (in bytes) /\r\n\t        uint16_t type;                                  / one of SYS_TYPE_ above /\r\n\t        uint16_t nlinks;                                / # of hard links to this file /\r\n\t        uint32_t blocks;                                / ……(1)…… /\r\n\t        uint32_t direct[SFS_NDIRECT];                   / ……(2)…… /\r\n\t        uint32_t indirect;                              / ……(3)…… /\r\n\t    //    uint32_t db_indirect;                           / double indirect blocks /\r\n\t    //   unused\r\n\t    };\r\n\t    / file entry (on disk) /\r\n\t    struct sfs_disk_entry {\r\n\t        uint32_t ino;                                   / inode number /\r\n\t        char name[SFS_MAX_FNAME_LEN + 1];               / file name /\r\n\t    };\r\n\t    #define sfs_dentry_size                             \\\r\n\t        sizeof(((struct sfs_disk_entry )0)->name)\r\n\t    / inode for sfs /\r\n\t    struct sfs_inode {\r\n\t        struct sfs_disk_inode din;                     / on-disk inode /\r\n\t        uint32_t ino;                                   / inode number /\r\n\t        bool dirty;                                     / true if inode modified /\r\n\t        int reclaim_count;                              / kill inode if it hits zero /\r\n\t        semaphore_t sem;                                / semaphore for din /\r\n\t        list_entry_t inode_link;         / entry for linked-list in sfs_fs /\r\n\t        list_entry_t hash_link;          / entry for hash linked-list in sfs_fs /\r\n\t    };\r\n\t    #define le2sin(le, member)                          \\\r\n\t        to_struct((le), struct sfs_inode, member)\r\n\t    / filesystem for sfs /\r\n\t    struct sfs_fs {\r\n\t        struct sfs_super super;                         / on-disk superblock /\r\n\t        struct device dev;                             / device mounted on /\r\n\t        struct bitmap freemap;                         / blocks in use are mared 0 /\r\n\t        bool super_dirty;                               / true if super/freemap modified /\r\n\t        void sfs_buffer;                  / buffer for non-block aligned io /\r\n\t        semaphore_t fs_sem;                             / semaphore for fs /\r\n\t        semaphore_t io_sem;                             / semaphore for io /\r\n\t        semaphore_t mutex_sem;              / semaphore for link/unlink and rename /\r\n\t        list_entry_t inode_list;                        / inode linked-list /\r\n\t        list_entry_t hash_list;                        / inode hash linked-list /\r\n\t    };\r\n\t    / hash for sfs /\r\n\t    #define SFS_HLIST_SHIFT                             10\r\n\t    #define SFS_HLIST_SIZE                              (1 << SFS_HLIST_SHIFT)\r\n\t    #define sin_hashfn(x)                               (hash32(x, SFS_HLIST_SHIFT))\r\n\t    / size of freemap (in bits) /\r\n\t    #define sfs_freemap_bits(super)           ROUNDUP((super)->blocks, SFS_BLKBITS)\r\n\t    / size of freemap (in blocks) /\r\n\t    #define sfs_freemap_blocks(super)         ROUNDUP_DIV((super)->blocks, SFS_BLKBITS)\r\n\t    struct fs;\r\n\t    struct inode;\r\n\t    void sfs_init(void);\r\n\t    int sfs_mount(const char devname);\r\n\t    void lock_sfs_fs(struct sfs_fs sfs);\r\n\t    void lock_sfs_io(struct sfs_fs sfs);\r\n\t    void lock_sfs_mutex(struct sfs_fs sfs);\r\n\t    void unlock_sfs_fs(struct sfs_fs sfs);\r\n\t    void unlock_sfs_io(struct sfs_fs sfs);\r\n\t    void unlock_sfs_mutex(struct sfs_fs sfs);\r\n\t    int sfs_rblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\r\n\t    int sfs_wblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\r\n\t    int sfs_rbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\r\n\t    int sfs_wbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\r\n\t    int sfs_sync_super(struct sfs_fs sfs);\r\n\t    int sfs_sync_freemap(struct sfs_fs sfs);\r\n\t    int sfs_clear_block(struct sfs_fs sfs, uint32_t blkno, uint32_t nblks);\r\n\t    int sfs_load_inode(struct sfs_fs sfs, struct inode node_store, uint32_t ino);\r\n\t    #endif / !__KERN_FS_SFS_SFS_H__ /\r\n\t    =============================================================\r\n\t    tools/mksfs.c\r\n\t    ======================= tools/mksfs.c===========================\r\n\t    ......\r\n\t    #define SFS_MAGIC                               0x2f8dbe2a\r\n\t    #define SFS_NDIRECT                             12\r\n\t    #define SFS_BLKSIZE                             4096                                    // 4K\r\n\t    #define SFS_MAX_NBLKS                           (1024UL  512)                          // 4K  512K\r\n\t    #define SFS_MAX_INFO_LEN                        31\r\n\t    #define SFS_MAX_FNAME_LEN                       255\r\n\t    #define SFS_MAX_FILE_SIZE                       (1024UL  1024  128)                   // 128M\r\n\t    #define SFS_BLKBITS                             (SFS_BLKSIZE  CHAR_BIT)\r\n\t    #define SFS_TYPE_FILE                           1\r\n\t    #define SFS_TYPE_DIR                            2\r\n\t    #define SFS_TYPE_LINK                           3\r\n\t    #define SFS_BLKN_SUPER                          0\r\n\t    #define SFS_BLKN_ROOT                           1\r\n\t    #define SFS_BLKN_FREEMAP                        2\r\n\t    struct cache_block {\r\n\t        uint32_t ino;\r\n\t        struct cache_block hash_next;\r\n\t        void cache;\r\n\t    };\r\n\t    struct cache_inode {\r\n\t        struct inode {\r\n\t            uint32_t size;\r\n\t            uint16_t type;\r\n\t            uint16_t nlinks;\r\n\t            uint32_t blocks;\r\n\t            uint32_t direct[SFS_NDIRECT];\r\n\t            uint32_t indirect;\r\n\t            uint32_t db_indirect;\r\n\t        } inode;\r\n\t        ino_t real;\r\n\t        uint32_t ino;\r\n\t        uint32_t nblks;\r\n\t        struct cache_block l1, l2;\r\n\t        struct cache_inode hash_next;\r\n\t    };\r\n\t    struct sfs_fs {\r\n\t        struct {\r\n\t            uint32_t magic;\r\n\t            uint32_t blocks;\r\n\t            uint32_t unused_blocks;\r\n\t            char info[SFS_MAX_INFO_LEN + 1];\r\n\t        } super;\r\n\t        struct subpath {\r\n\t            struct subpath next, prev;\r\n\t            char subname;\r\n\t        } __sp_nil, sp_root, sp_end;\r\n\t        int imgfd;\r\n\t        uint32_t ninos, next_ino;\r\n\t        struct cache_inode root;\r\n\t        struct cache_inode inodes[HASH_LIST_SIZE];\r\n\t        struct cache_block blocks[HASH_LIST_SIZE];\r\n\t    };\r\n\t    struct sfs_entry {\r\n\t        uint32_t ino;\r\n\t        char name[SFS_MAX_FNAME_LEN + 1];\r\n\t    };\r\n\t    static uint32_t\r\n\t    sfs_alloc_ino(struct sfs_fs sfs) {\r\n\t        if (sfs->next_ino < sfs->ninos) {\r\n\t            sfs->super.unused_blocks --;\r\n\t            return sfs->next_ino ++;\r\n\t        }\r\n\t        bug(\"out of disk space.\r\n\t\");\r\n\t    }\r\n\t    ......\r\n\t    #define show_fullpath(sfs, name) subpath_show(stderr, sfs, name)\r\n\t    void open_dir(struct sfs_fs sfs, struct cache_inode current, struct cache_inode parent);\r\n\t    void open_file(struct sfs_fs sfs, struct cache_inode file, const char filename, int fd);\r\n\t    void open_link(struct sfs_fs sfs, struct cache_inode file, const char filename);\r\n\t    #define SFS_BLK_NENTRY                          (SFS_BLKSIZE / sizeof(uint32_t))\r\n\t    #define SFS_L0_NBLKS                            SFS_NDIRECT\r\n\t    #define SFS_L1_NBLKS                            (SFS_BLK_NENTRY + SFS_L0_NBLKS)\r\n\t    #define SFS_L2_NBLKS                            (SFS_BLK_NENTRY  SFS_BLK_NENTRY + SFS_L1_NBLKS)\r\n\t    #define SFS_LN_NBLKS                            (SFS_MAX_FILE_SIZE / SFS_BLKSIZE)\r\n\t    static void\r\n\t    update_cache(struct sfs_fs sfs, struct cache_block cbp, uint32_t inop) {\r\n\t        uint32_t ino = inop;\r\n\t        struct cache_block cb = cbp;\r\n\t        if (ino == 0) {\r\n\t            cb = alloc_cache_block(sfs, 0);\r\n\t            ino = cb->ino;\r\n\t        }\r\n\t        else if (cb == NULL || cb->ino != ino) {\r\n\t            cb = search_cache_block(sfs, ino);\r\n\t            assert(cb != NULL && cb->ino == ino);\r\n\t        }\r\n\t        cbp = cb, inop = ino;\r\n\t    }\r\n\t    static void\r\n\t    append_block(struct sfs_fs sfs, struct cache_inode file, size_t size, uint32_t ino, const char filename) {\r\n\t        static_assert(SFS_LN_NBLKS <= SFS_L2_NBLKS);\r\n\t        assert(size <= SFS_BLKSIZE);\r\n\t        uint32_t nblks = file->nblks;\r\n\t        struct inode inode = &(file->inode);\r\n\t        if (nblks >= SFS_LN_NBLKS) {\r\n\t            open_bug(sfs, filename, \"file is too big.\r\n\t\");\r\n\t        }\r\n\t        if (nblks < SFS_L0_NBLKS) {\t/ ……(4)…… /\r\n\t            inode->direct[nblks] = ino;\t/ ……(5)…… /\r\n\t        }\r\n\t        else if (nblks < SFS_L1_NBLKS) {\t/ ……(6)…… /\r\n\t            nblks -= SFS_L0_NBLKS;\t\t/ ……(7)…… /\r\n\t            update_cache(sfs, &(file->l1), &(inode->indirect));\r\n\t            uint32_t data = file->l1->cache;\r\n\t            data[nblks] = ino;\t\t\t/ ……(8)…… /\r\n\t        }\r\n\t        else if (nblks < SFS_L2_NBLKS) {\t/ ……(9)…… /\r\n\t            nblks -= SFS_L1_NBLKS;\t\t/ ……(10)…… /\r\n\t            update_cache(sfs, &(file->l2), &(inode->db_indirect));\r\n\t            uint32_t data2 = file->l2->cache;\r\n\t            update_cache(sfs, &(file->l1), &data2;[nblks / SFS_BLK_NENTRY]);\r\n\t            uint32_t data1 = file->l1->cache;\r\n\t            data1[nblks % SFS_BLK_NENTRY] = ino;\t/ ……(11)…… /\r\n\t        }\r\n\t        file->nblks ++;\r\n\t        inode->size += size;\r\n\t        inode->blocks ++;\t/ ……(12)…… /\r\n\t    }\r\n\t    ......\r\n\t    =============================================================\r\n\t    ```", "degree_of_difficulty": "1", "source": "网络", "answer": "第1问6分；第2问6分；第3问6分；", "type": "question_answer", "options": "  \r\n"}